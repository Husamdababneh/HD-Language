/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}
/* */ 
/* ========================================================================
   $File: lex.cpp
   $Date: 2020-04-04
   $Revision: : @Incomplete
   $Creator: Husam Dababneh
   $Description: Defines Lexer functionality & Data Structures
   ========================================================================*/ 
#pragma
/s
#pragma once
/* This is a comment */

// Hello This is also a comment

/* This is also */

/*
	This is multiline comment 
	/*
		This is nested multiline comment 
	*/
*/

Header :: struct {
	Tag     : [4] #char = "PAK"; // first 3 characters are constants 
	IDK     : u32;
	Version : u32;
	ResNum  : u32;
}
			/* aa */
			

// This should have variable size
FilesHeaders : [Header.ResNum] {
	Filename	: [..] #char;
	Null		: #char = "\0" ; // this is a constant 
	ROFF		: u32;
	Size		: u32;
	Unknown1	: u32;
	Unknown2	: u32;
};

// variable size
FilesData :: [Header.ResNum]
{
	IF Header.Tag[3]== "A" {
	   Read it.Size;
	}
	
	IF Header.Tag[3]== "C" {
	   PackedBlockSize = Read sizeof(u32);
	   UnpackedBlockSize = Read sizeof(u32);
	   PackedData = Read PackedBlockSize;
	   UnpackedData : [UnpackedBlockSize]u8 ;
	   decompress(data,PackedBlockSize, UnpackedData);
	}
};


code :: () {
	Proccess Header no_out;
	Proccess FilesHeaders;
	Proceess FilesData;
	b = a + 5;
}